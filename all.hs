import Maybe
import Monad
import List
import Test.HUnit

-----------------------------------
------ helper functions -----------
-----------------------------------
stringToInt :: String -> Int
stringToInt s = (read s) :: Int
charToInt :: Char -> Int
charToInt c = stringToInt [c]
stringToIntList s = map charToInt s
intToIntList n = stringToIntList (show n)
letters = ['A'..'Z']
-- there might be a built in way to do this, or a better way in general.
slices :: Int -> [a] -> [[a]]
slices n [] = []
slices n all@(x:xs) = break all [] where
        break [] acc = acc
        break all@(x:xs) acc = break xs ((take n all):acc)
triangeNums = [n*(n+1)/2|n<-[1..]]

--------------------
------ 1 -----------
--------------------
-- If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. 
-- The sum of these multiples is 23.
-- Find the sum of all the multiples of 3 or 5 below 1000.

actual1 = sum [n|n<-[1..999], n `mod` 3 == 0 || n `mod` 5 == 0]
expected1 = 233168
problem1Tests = runTests [Test "1" expected1 actual1]

--------------------
------ 2 -----------
--------------------
-- Each new term in the Fibonacci sequence is generated by adding the previous two terms.
-- By starting with 1 and 2, the first 10 terms will be:
-- 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
-- Find the sum of all the even-valued terms in the sequence which do not exceed four million.

fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
actual2 = sum (filter even (takeWhile (<4000000) fibs))
expected2 = 4613732
problem2Tests = runTests [Test "2" expected2 actual2]

--------------------
------ 3 -----------
--------------------
-- The prime factors of 13195 are 5, 7, 13 and 29.
-- What is the largest prime factor of the number 600851475143 ?

-- TODO performance is terrible here.

primes = sieve [2..] where 
	sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0]
primesToN n = takeWhile (<n) primes
-- this should definitely be n/2...but i am fighting with the type system on that.
primeFactors n = [x|x<-primesToN n, n `mod` x == 0]

actual3 = head (reverse (primeFactors 600851475143))
expected3 = 4613732
problem3Tests = runTests [Test "3" expected3 actual3]

--------------------
------ 4 -----------
--------------------
-- A palindromic number reads the same both ways. 
-- The largest palindrome made from the product of two 2-digit numbers is 9009 = 91  99.
-- Find the largest palindrome made from the product of two 3-digit numbers.

isPal n = show n == reverse (show n)
actual4 = maximum (filter isPal [(x*y) | x <- [100..999], y <- [100..999]])
expected4 = 906609
problem4Tests = runTests [Test "4" expected4 actual4]

--------------------
------ 5 -----------
--------------------
-- 2520 is the smallest number that can be divided by each of the numbers 
-- from 1 to 10 without any remainder.
-- What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

-- TODO this takes about 30 seconds...figure out a way to trim it down

numsWeCareAbout = [3,6,7,8,9,11,13,14,15,16,17,18,19]
divisibleByFirst20 n = null (dropWhile (\x -> n `mod` x == 0) numsWeCareAbout) 
actual5 = head (dropWhile (not . divisibleByFirst20) [20, 40..]) 
expected5 = 232792560
problem5Tests = runTests [Test "5" expected5 actual5]

--------------------
------ 6 -----------
--------------------
-- The sum of the squares of the first ten natural numbers is,
-- 1^2 + 2^2 + ... + 10^2 = 385
-- The square of the sum of the first ten natural numbers is,
-- (1 + 2 + ... + 10)^2 = 55^2 = 3025
-- Hence the difference between the sum of the squares of the first ten 
-- natural numbers and the square of the sum is 3025  385 = 2640.
-- Find the difference between the sum of the squares of the first 
-- one hundred natural numbers and the square of the sum.

square n = n * n
naturals = [1..]
squares = [x*x|x<-naturals]
sumOfSquaresTo n = sum (take n squares)
squareOfSumsTo n = square (sum (take n naturals))
actual6 = squareOfSumsTo 100 - sumOfSquaresTo 100 
expected6 = 25164150
problem6Tests = runTests [Test "6" expected6 actual6]

--------------------
------ 7 -----------
--------------------
-- By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
-- What is the 10001st prime number?

-- TODO performance is terrible here (because of primes)

actual7 = primes !! 10000
expected7 = 1213123
problem7Tests = runTests [Test "7" expected7 actual7]

--------------------
------ 8 -----------
--------------------
-- Find the greatest product of five consecutive digits in the 1000-digit number.
crazy = "731671765313306249192251196744265747423553491949349698352031277450632623957831801698480186947885184385861560789112949495459501737958331952853208805511125406987471585238630507156932909632952274430435576689664895044524452316173185640309871112172238311362229893423380308135336276614282806444486645238749303580729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"

-- actual impl
actual8 = maximum (map (\x -> foldl (*) 1 x) (map stringToIntList (slices 5 crazy))) 
expected8 = 40824
problem8Tests = runTests [Test "8" expected8 actual8]

--------------------
------ 9 -----------
--------------------
-- A Pythagorean triplet is a set of three natural numbers, a  b  c, for which,
-- a^2 + b^2 = c^2
-- For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
-- There exists exactly one Pythagorean triplet for which a + b + c = 1000.
-- Find the product abc.

-- certainly there is a more clever way to do this than my guessing...
actual9 = [a*b*c|a <- [1..300], b <- [1..400], c <- [400..998], a+b+c==1000 && a*a + b*b == c*c] !! 0 
expected9 = 31875000
problem9Tests = runTests [Test "9" expected9 actual9]

--------------------
------ 10 ----------
--------------------
-- The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
-- Find the sum of all the primes below two million.

-- once again performance is terrible because of the original primes impl
actual10 = sum (primesToN 2000000)
expected10 = 1
problem10Tests = runTests [Test "10" expected10 actual10]

--------------------
------ 11 ----------
--------------------
grid = [[08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08],
	[49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00],
	[81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65],
	[52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91],
	[22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80],
	[24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50],
	[32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70],
	[67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21],
	[24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72],
	[21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95],
	[78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92],
	[16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57],
	[86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58],
	[19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40],
	[04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66],
	[88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69],
	[04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36],
	[20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16],
	[20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54],
	[01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48]]

matrixRow :: Int -> [[a]] -> [a]
matrixRow n matrix = matrix !! n
matrixCol :: Int -> [[a]] -> [a]
matrixCol n matrix = map (\x -> x !! n) matrix

matrixSize matrix = length matrix
data HorizontalDir = HorizontalRight | HorizontalLeft
data VerticalDir = VerticalUp | VerticalDown

matrixDiagonal :: (Int,Int) -> (HorizontalDir,VerticalDir) -> [[a]] -> [a]
matrixDiagonal (x,y) (h,v) matrix = 
	let indicies = matrixDiagonalIndicies (x,y) (h,v) (matrixSize matrix)
	in map (\(x,y) -> (matrixCol x matrix) !! y) indicies

matrixDiagonalIndicies :: (Int,Int) -> (HorizontalDir,VerticalDir) -> Int -> [(Int,Int)]
matrixDiagonalIndicies (x,y) (HorizontalRight,VerticalUp) size = 
	let 	distance = min (size - x) (y+1)
	in	zip [x..(x+(distance-1))] (if distance == 1 then [y] else [y,(y-1)..((distance-1)-y)])
matrixDiagonalIndicies (x,y) (HorizontalRight,VerticalDown) size = 
        let     distance = min (size - x) (size - y)
       	in	zip [x..(x+(distance-1))] [y..(y+(distance-1))]
matrixDiagonalIndicies (x,y) (HorizontalLeft,VerticalUp) size =  
        let     distance = min (x+1) (y+1)
	in 	zip (if distance == 1 then [x] else [x,(x-1)..((distance-1)-x)])
			(if distance == 1 then [y] else [y,(y-1)..((distance-1)-y)])
matrixDiagonalIndicies (x,y) (HorizontalLeft,VerticalDown) size =
	let     distance = min (x+1) (size - y)
        in	zip (if distance == 1 then [x] else [x,(x-1)..((distance-1)-x)]) [y..(y+(distance-1))]

-- next steps... 
-- get all rows - map (\x -> matrixRow x matrix) [0..19] 
-- get all cols - map (\x -> matrixCol x matrix) [0..19]
-- get all diagonals
-- from 0..19 get all the diagonals going down, and right. 
-- from 19,18..0 get all the diagonals going down, and left. 
-- from 0..19 get all the diagonals going up, and right. 
-- from 19,18..0 get all the diagonals going up, and left. 

-- put them all in one giant [[int]]
-- slice them all into 4's [[[int]]]
-- join [[int]]
-- max of multiply each...

--------------------
------ 14 ----------
--------------------
-- The following iterative sequence is defined for the set of positive integers:
-- n  n/2 (n is even)
-- n  3n + 1 (n is odd)
-- Using the rule above and starting with 13, we generate the following sequence:
-- 13  40  20  10  5  16  8  4  2  1
-- It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms.
-- Although it has not been proved yet (Collatz Problem), 
-- it is thought that all starting numbers finish at 1.
-- Which starting number, under one million, produces the longest chain?

evenoddchainlength n = length (unfoldr succ n) where 
	tochainnum n = if odd n then 3*n+1 else div n 2
	succ n = if n == 1 then Nothing else Just (n, tochainnum n)
chaincompare (n, size) next = 
	let nextlength = evenoddchainlength next
	in if nextlength > size then (next, nextlength) else (n,size)
actual14 = foldl chaincompare (0,0) [1..100000]

--------------------
------ 20 ----------
--------------------
--n! means n  (n  1)  ...  3  2  1
--Find the sum of the digits in the number 100!
fac n = foldl (*) 1 [1..n]
actual20 = sum (intToIntList (fac 100))
expected20 = 648
problem20Tests = runTests [Test "20" expected20 actual20]

--------------------
------ 22 ----------
--------------------
-- Using names.txt (right click and 'Save Link/Target As...'),
-- a 46K text file containing over five-thousand first names, 
-- begin by sorting it into alphabetical order. 
-- Then working out the alphabetical value for each name, 
-- multiply this value by its alphabetical position in the list to obtain a name score.
-- For example, when the list is sorted into alphabetical order, COLIN, 
-- which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. 
-- So, COLIN would obtain a score of 938  53 = 49714.
-- What is the total of all the name scores in the file?

-- start with just a few of the names already in a string
names = sort ["MARY","PATRICIA","LINDA","BARBARA","ELIZABETH","JENNIFER","MARIA","SUSAN"]
positions = map (\x -> map (\c -> fromJust (elemIndex c letters) + 1) x) names

--------------------
------ 25 ----------
--------------------
actual25 = fromJust (findIndex (\x -> (length (show x)) >= 1000) fibs)
expected25 = 4782
problem25Tests = runTests [Test "25" expected25 actual25]

--------------------
------ tests -------
--------------------

data Test a = Test {name :: String, expected :: a, actual :: a} deriving (Show)
runTests xs = runTestTT (TestList (map maketest xs)) 
	where maketest ta = 
    		TestLabel (name ta) (TestCase (assertEqual (name ta) (expected ta) (actual ta)))
--allTests = [problem1Tests, problem2Tests, primeTests]
